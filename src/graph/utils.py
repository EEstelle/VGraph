import networkx as nx
import os
import pickle as pkl
import csv


def joern_edge_to_edgelist(edge_file):
    ''' converts an edges.csv file generated by Joern into a simple edgelist '''
    edge_list = {}
    with open(edge_file, 'r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter='\t')
        first_line = True
        for row in csv_reader:
            # Skip first line
            if first_line:
                first_line = False
                continue
            if row[0] not in edge_list:
                edge_list[row[0]] = [ (row[1], row[2]) ]
            else:
                edge_list[row[0]].append((row[1], row[2]))

    return edge_list


def joern_to_networkx(nodes_file,  edge_file, func_names=None):
    ''' Converts a joern nodes.csv and edges.csv into a list of NetworkX graphs '''

    edge_list = joern_edge_to_edgelist(edge_file)

    graphs = []
    total_funcs_parsed = 0
    with open(nodes_file, 'r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter='\t')
        first_line = True
        processing_func = False
        curr_meta = {}
        for row in csv_reader:
            # Skip first line
            if first_line:
                first_line = False
                continue
            if row[2] == "Function":
                total_funcs_parsed += 1
                if processing_func: # New function so stop previous function processing
                    # add edges
                    for src_n in curr_meta['graph'].nodes():
                        if src_n in edge_list:
                           for (dst_n, e_type) in edge_list[src_n]:
                               curr_meta['graph'].add_edge(src_n, dst_n, type=e_type)
                    graphs.append(curr_meta)
                    processing_func = False
                    curr_meta = {}

                # Found a new function
                # row[4] is function name
                # row[5] is function location in line_num:x:x:x
                if not func_names or row[3] in func_names:
                    curr_meta['location'] = row[4]
                    curr_meta['graph'] = nx.MultiDiGraph()
                    curr_meta['name'] = row[3]
                    processing_func = True
            else:
                # not a function start.  so just see if we processing or not
                if processing_func:
                    curr_meta['graph'].add_node(row[1]) # add node to graph
                    curr_meta['graph'].node[row[1]]['type'] = row[2]
                    curr_meta['graph'].node[row[1]]['code'] = row[3]
                    curr_meta['graph'].node[row[1]]['functionId'] = row[5]
        # end of csv file
        # lets check to make sure we didnt end on a function we were processing
        if processing_func:
            # need to finish off this function
            # add edges
            for src_n in curr_meta['graph'].nodes():
                if src_n in edge_list:
                    for (dst_n, e_type) in edge_list[src_n]:
                        curr_meta['graph'].add_edge(src_n, dst_n, type=e_type)
            graphs.append(curr_meta)
            processing_func = False
    # now we have processed both the nodes.csv and edges.csv for this source code file
    return graphs, total_funcs_parsed

def tripleize(G):
    ''' Turns a graph into a set of code -> Relationship -> Code triples '''
    G_trips=set([])

    for n1, n2, k in G.edges(keys=True):
        if G.node[n1]['type'] in ['CFGEntryNode','CFGExitNode','ENTRY','EXIT']:
            continue
        if G.node[n2]['type'] in ['CFGEntryNode','CFGExitNode','ENTRY','EXIT']:
            continue
        relationship=G[n1][n2][k]['type']
        # first add pure type relationships. This is most abstract form
        G_trips.add((G.node[n1]['type'],relationship,G.node[n2]['type']))
        # One node set to concrete src code
        if G.node[n1]['code'] != '':
            G_trips.add((G.node[n1]['code'],relationship,G.node[n2]['type'])) 
        # Other node set to concrete src code
        if G.node[n2]['code'] != '':
            G_trips.add((G.node[n1]['type'],relationship,G.node[n2]['code']))
        # Both nodes set to concrete src code
        if G.node[n1]['code'] != '' and G.node[n2]['code'] != '':
            G_trips.add((G.node[n1]['code'],relationship,G.node[n2]['code']))
        
    return G_trips


def vectorize(G):
    ''' Converts a graph to a vector based on node and edge types.  Can be used for quick filtering '''
    vector_dims = [ 'FLOWS_TO','DECLARES','IS_CLASS_OF','REACHES','CONTROLS','DOM','POST_DOM','USE','DEF','IS_AST_PARENT','CallExpression','Callee','Function','ArgumentList','AssignmentExpr','File','IdentifierDeclStatement','Parameter','Symbol', 'PostIncDecOperationExpression', 'Identifier', 'IncDec', 'ExpressionStatement', 'AssignmentExpression', 'ArrayIndexing','IfStatement', 'Condition', 'AdditiveExpression', 'Argument' , 'PrimaryExpression', 'CastExpression', 'CastTarget', 'PtrMemberAccess','Statement', 'ReturnStatement', 'EqualityExpression', 'ElseStatement', 'ParameterType', 'ParameterList', 'SizeofExpression', 'IdentifierDeclType', 'UnaryOperator', 'MultiplicativeExpression', 'MemberAccess', 'FunctionDef', 'AndExpression', 'CFGEntryNode', 'UnaryOperationExpression', 'ForStatement', 'ForInit', 'ShiftExpression', 'ReturnType', 'Sizeof', 'BreakStatement', 'OrExpression', 'WhileStatement', 'SizeofOperand', 'IdentifierDecl', 'CompoundStatement', 'CFGExitNode', 'RelationalExpression', 'BitAndExpression','CFGErrorNode','ClassDef','ClassDefStatement','ConditionalExpression','ContinueStatement','Decl','DeclStmt','DoStatement','ExclusiveOrExpression','Expression','GotoStatement','InclusiveOrExpression','InitializerList','Label','SwitchStatement','UnaryExpression','InfiniteForNode']
    vec = [0] * len(vector_dims)
    for n in G.nodes():
        t = G.node[n]['type']
        if t in vector_dims:
            vec[vector_dims.index(t)] += 1
        else:
            print("Missing node type: ", t)

    for (n1,n2) in G.edges():
        for e in G[n1][n2]: # multi edges
            t = G[n1][n2][e]['type']
            if t in vector_dims:
                vec[vector_dims.index(t)] += 1
            else:
                print("Missing edge type: ", t)
    return vec




def load_vgraph_db(root):
    vgraph_db=[]
    for repo in os.listdir(root):
        for cve in os.listdir('/'.join([root,repo])):
            for hsh in os.listdir('/'.join([root,repo,cve])):
                for f in os.listdir('/'.join([root,repo,cve,hsh])):
                    for func in os.listdir('/'.join([root,repo,cve,hsh,f])):
                        if func.endswith('_pvg.pkl'):
                            # Found vGraph
                            func_root = str(func[:-len('_pvg.pkl')])
                            cvg=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'cvg.pkl'),'rb'))
                            pvg=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'pvg.pkl'),'rb'))
                            nvg=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'nvg.pkl'),'rb'))
                            v=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'v.pkl'),'rb'))
                            p=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'p.pkl'),'rb'))
                            vec=pkl.load(open(root + '/%s/%s/%s/%s/%s_%s'%(repo,cve,hsh,f,func_root,'vec.pkl'),'rb'))
                            vgraph_db.append({
                                'repo':repo,
                                'cve':cve,
                                'hsh':hsh,
                                'file':f,
                                'func':func_root,
                                'cvg':cvg,
                                'pvg':pvg,
                                'nvg':nvg,
                                'v':v,
                                'p':p,
                                'vec':vec
                            })

    return vgraph_db

def load_target_db(root, func_list=None):
    target_graph_db = []
    for root, dirs, files in os.walk(root):
        for f in files:
            if f.endswith(".gpickle"): # this is a target graph
                base_name = f[:-len('.gpickle')]
                if func_list and base_name not in func_list:
                    continue
                try:
                    target_graph_db.append({
                        'dir': root,
                        'base_name': base_name,
                        'path':"%s/%s" % (root, f),
                        #'graph': nx.read_gpickle("%s/%s" % (root, f)),
                        'triples': pkl.load(open("%s/%s" % (root, base_name + '.triples'), 'rb')),
                        'vec': pkl.load(open("%s/%s" % (root, base_name + '.vec'), 'rb'))
                    })
                except:
                    # error loading target.  skip.
                    continue
    return target_graph_db


