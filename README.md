# vGraph

## Vulnerability Source Code Database Generation

First, navigate to ```vuln_src_db```.  This is the directory where we will harvest code from Github

### Step 1: Configure Github Repositories

The Github repositories that will be mined are in the file `repos.config`.  Add any repositories to the file in the format `<name> <url>`.

### Step 2: Clone Repositories

Run the script `gen_repos.sh`.  This will clone all of the repositories in `repos.config`.  Make sure you have enough disk space in the current directory.

### Step 3: Identify commits related to CVE numbers

Run the script `gen_relevant_commits.sh`.  This will mine Github logs looking for mentions of CVE numbers.  Commit hashes will be saved to files.

### Step 4: Download source code files associated with commits

Run the script `gen_scr_files.sh`.  This will download the raw source code file(s) associated with a commit.  In addition, we write out the function names that were modified with each commit.  This way we know which functions are associated with the vulnerability.

## Vulnerability Source Code Parsing

Next, we will utilize the open source tool Joern to parse our source code.

### Step 1: Install Joern

Clone Joern from : https://github.com/octopus-platform/joern.  Follow the instructions in order to build the Java app.

### Step 2: Parse with joern-parse

Use the joern-parse tool to parse the vulnerable source code we just generated.  Provide the full path to the source code directory.
```
$./joern-parse /path/to/vuln_src_db
```
This will create a directory named `parsed` in your current working directory.  This directory contains all of the parsed content in the form of two files for each source file: nodes.csv and edges.csv.  

Once this directory is built, move it into the `vuln_src_db` directory before moving onto the next step.

### Step 3: Convert Parsed Output

Next we will convert the .csv files generated by Joern into Python NetworkX format.  While we do that, we will also extract the original vulnerable and patched functions from the source code directly.

To do this, simply run `convert_parsed.py` inside the `vuln_src_db` directory (make sure the `parsed` directory from the previous step has already been moved there.

This will createa  new directory named `vuln_patch_graph_db` which contains the source code for every vulnerable/patch function, as well as the NetworkX graph representation of the Code Property Graph for that function.  The directory is laid out as folows:
```
vuln_patch_graph_db/<repository>/<CVE>/<vuln|patch>/<src_file_name>/<code|graph>/<function_name>.<c|gpickle>
```

## Generate vGraphs

The next step is to actually build the vGraphs from the CPGs of the vulnerable and patched functions.

TODO

### Generate pCVG and nCVG for each vuln/patch pair in our database

Next we will be generating our positive Core Vulnerability Graph (pCVG), and our negative Core Vulnerability Graph (nCVG).  a simple script takes care of this.

```
./gen_core_vuln_graphs.sh
```

## Vulnerability Extrapolation

### Joern Database Setup

We utilize Joern to generate the Code Property Graph (CPG) of all functions in our target source code.

```
joern <source_code_directory>
```

The result of this command will be a hidden file ```.joernIndex``` which will be used with Neo4j.  Point neo4j server to this file and start it with ```neo4j console```.

### Generate Target Graph Database

Now we will utilize Joern and Neo4j to export the CPG of each function into NetworkX format for processing

```
./gen_target_graph_db.sh
```

### Vulnerability Extrapolation

Now, using the TALE approximate graph matching algorithm, we will compare target functions against the pCVG and nCVG in order to identify possible vulnerabilities.

```
./find_matches.py
```
